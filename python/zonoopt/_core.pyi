import numpy
import scipy.sparse

class ADMM_settings:
    eps_dual: float
    eps_prim: float
    inf_norm_conv: bool
    k_inf_check: int
    k_max: int
    rho: float
    t_max: float
    verbose: bool
    verbosity_interval: int
    def __init__(self) -> None: ...

class ADMM_solution:
    J: float
    converged: bool
    dual_residual: float
    infeasible: bool
    k: int
    primal_residual: float
    run_time: float
    startup_time: float
    u: numpy.ndarray[numpy.float64[m, 1]]
    x: numpy.ndarray[numpy.float64[m, 1]]
    z: numpy.ndarray[numpy.float64[m, 1]]
    def __init__(self) -> None: ...

class ADMM_solver:
    def __init__(self) -> None: ...
    def factorize(self) -> None: ...
    def setup(self, P: scipy.sparse.csc_matrix[numpy.float64], q: numpy.ndarray[numpy.float64[m, 1]], A: scipy.sparse.csc_matrix[numpy.float64], b: numpy.ndarray[numpy.float64[m, 1]], x_l: numpy.ndarray[numpy.float64[m, 1]], x_u: numpy.ndarray[numpy.float64[m, 1]], settings: ADMM_settings = ..., c: float = ...) -> None: ...
    def solve(self) -> ADMM_solution: ...
    def update_A(self, A: scipy.sparse.csc_matrix[numpy.float64]) -> None: ...
    def update_P(self, P: scipy.sparse.csc_matrix[numpy.float64]) -> None: ...
    def update_b(self, b: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def update_bounds(self, x_l: numpy.ndarray[numpy.float64[m, 1]], x_u: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def update_c(self, c: float) -> None: ...
    def update_q(self, q: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
    def update_settings(self, settings: ADMM_settings) -> None: ...
    def warmstart(self, x: numpy.ndarray[numpy.float64[m, 1]], u: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...

class AbstractZono:
    def __init__(self, *args, **kwargs) -> None: ...
    def bounding_box(self, settings: ADMM_settings = ..., solution: ADMM_solution = ...) -> AbstractZono: ...
    def contains_point(self, x: numpy.ndarray[numpy.float64[m, 1]], settings: ADMM_settings = ..., solution: ADMM_solution = ...) -> bool: ...
    def convert_form(self) -> None: ...
    def is_conzono(self) -> bool: ...
    def is_empty(self, settings: ADMM_settings = ..., solution: ADMM_solution = ...) -> bool: ...
    def is_hybzono(self) -> bool: ...
    def is_point(self) -> bool: ...
    def is_zono(self) -> bool: ...
    def optimize_over(self, P: scipy.sparse.csc_matrix[numpy.float64], q: numpy.ndarray[numpy.float64[m, 1]], c: float = ..., settings: ADMM_settings = ..., solution: ADMM_solution = ...) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def project_point(self, x: numpy.ndarray[numpy.float64[m, 1]], settings: ADMM_settings = ..., solution: ADMM_solution = ...) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def remove_redundancy(self) -> None: ...
    def support(self, d: numpy.ndarray[numpy.float64[m, 1]], settings: ADMM_settings = ..., solution: ADMM_solution = ...) -> float: ...

class ConZono(AbstractZono):
    def __init__(self, G: scipy.sparse.csc_matrix[numpy.float64] = ..., c: numpy.ndarray[numpy.float64[m, 1]] = ..., A: scipy.sparse.csc_matrix[numpy.float64] = ..., b: numpy.ndarray[numpy.float64[m, 1]] = ..., zero_one_form: bool = ...) -> None: ...
    def get_A(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_G(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_b(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_c(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_n(self) -> int: ...
    def get_nC(self) -> int: ...
    def get_nG(self) -> int: ...
    def is_0_1_form(self) -> bool: ...
    def set(self, G: scipy.sparse.csc_matrix[numpy.float64], c: numpy.ndarray[numpy.float64[m, 1]], A: scipy.sparse.csc_matrix[numpy.float64], b: numpy.ndarray[numpy.float64[m, 1]], zero_one_form: bool = ...) -> None: ...

class HybZono(AbstractZono):
    def __init__(self, Gc: scipy.sparse.csc_matrix[numpy.float64] = ..., Gb: scipy.sparse.csc_matrix[numpy.float64] = ..., c: numpy.ndarray[numpy.float64[m, 1]] = ..., Ac: scipy.sparse.csc_matrix[numpy.float64] = ..., Ab: scipy.sparse.csc_matrix[numpy.float64] = ..., b: numpy.ndarray[numpy.float64[m, 1]] = ..., zero_one_form: bool = ...) -> None: ...
    def convex_relaxation(self) -> ConZono: ...
    def get_A(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_Ab(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_Ac(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_G(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_Gb(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_Gc(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_b(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_c(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_n(self) -> int: ...
    def get_nC(self) -> int: ...
    def get_nG(self) -> int: ...
    def get_nGb(self) -> int: ...
    def get_nGc(self) -> int: ...
    def is_0_1_form(self) -> bool: ...
    def set(self, Gc: scipy.sparse.csc_matrix[numpy.float64], Gb: scipy.sparse.csc_matrix[numpy.float64], c: numpy.ndarray[numpy.float64[m, 1]], Ac: scipy.sparse.csc_matrix[numpy.float64], Ab: scipy.sparse.csc_matrix[numpy.float64], b: numpy.ndarray[numpy.float64[m, 1]], zero_one_form: bool = ...) -> None: ...

class Point(AbstractZono):
    def __init__(self, c: numpy.ndarray[numpy.float64[m, 1]] = ...) -> None: ...
    def get_c(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_n(self) -> int: ...
    def set(self, c: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...

class Zono(AbstractZono):
    def __init__(self, G: scipy.sparse.csc_matrix[numpy.float64] = ..., c: numpy.ndarray[numpy.float64[m, 1]] = ..., zero_one_form: bool = ...) -> None: ...
    def get_G(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def get_c(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def get_n(self) -> int: ...
    def get_nG(self) -> int: ...
    def is_0_1_form(self) -> bool: ...
    def set(self, G: scipy.sparse.csc_matrix[numpy.float64], c: numpy.ndarray[numpy.float64[m, 1]], zero_one_form: bool = ...) -> None: ...

def affine_map(Z: AbstractZono, R: scipy.sparse.csc_matrix[numpy.float64], s: numpy.ndarray[numpy.float64[m, 1]] = ...) -> AbstractZono: ...
def cartesian_product(Z1: AbstractZono, Z2: AbstractZono) -> AbstractZono: ...
def halfspace_intersection(Z: AbstractZono, H: scipy.sparse.csc_matrix[numpy.float64], f: numpy.ndarray[numpy.float64[m, 1]], R: scipy.sparse.csc_matrix[numpy.float64] = ...) -> AbstractZono: ...
def intersection(Z1: AbstractZono, Z2: AbstractZono, R: scipy.sparse.csc_matrix[numpy.float64] = ...) -> AbstractZono: ...
def intersection_over_dims(Z1: AbstractZono, Z2: AbstractZono, dims: list[int]) -> AbstractZono: ...
def make_regular_zono_2D(radius: float, n_sides: int, outer_approx: bool = ..., c: numpy.ndarray[numpy.float64[2, 1]] = ...) -> Zono: ...
def minkowski_sum(Z1: AbstractZono, Z2: AbstractZono) -> AbstractZono: ...
def pontry_diff(Z1: AbstractZono, Z2: AbstractZono) -> AbstractZono: ...
def project_onto_dims(Z: AbstractZono, dims: list[int]) -> AbstractZono: ...
def union_of_many(Z_list: list[AbstractZono]) -> AbstractZono: ...
def vrep_2_conzono(Vpoly: numpy.ndarray[numpy.float64[m, n]]) -> ConZono: ...
def vrep_2_hybzono(Vpolys: list[numpy.ndarray[numpy.float64[m, n]]]) -> HybZono: ...
def zono_union_2_hybzono(Zs: list[AbstractZono]) -> HybZono: ...
